<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q&A</title>
    <style>
        details {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: .75rem 1rem;
            margin: .5rem 0;
            background: #fafafa;
        }
        summary {
            cursor: pointer;
            font-weight: 600;
            list-style: none; /* Firefox 用 */
        }

        /* 既定の三角マーカーを消して独自のアイコンを付ける */
        summary::-webkit-details-marker { display: none; }
        summary::before {
            content: "▸";
            display: inline-block;
            width: 1em;
            transition: transform .2s;
            margin-right: .25rem;
        }

        details[open] > summary::before {
            transform: rotate(90deg);
        }
        .answer { margin-top: .5rem; line-height: 1.8; }
    </style>
</head>
<body>
    <h1>ゲームのQ&A</h1>
    <h2>1. ゲームの内容について</h2>
    <details>
        <summary>まずはこれ！</summary>
            <div class="answer">
                // ここにチュートリアルの動画のリンクのqrコードを貼る！
            </div>
    </details>
    <details>
        <summary>Q1-1. 難易度選択はどうなってるの？</summary>
            <div class="answer">
                難易度は、「簡単」・「普通」の２段階があります。腹筋ローラーを黄色い葉っぱの線まで伸ばしたあと緑の線まで戻せば「簡単モード」、奥の赤い葉っぱの線まで伸ばしたあと緑の線まで戻せば「普通モード」となります。
                <br>
                ※ゲーム内での表記は、ひらがなで「かんたん」・「ふつう」となっています。                
            </div>
    </details>
    <details>
        <summary>Q1-2. 1プレイは何分くらい？</summary>
            <div class="answer">
                各難易度ごとに制限時間が設定されていて、「簡単モード」なら80秒、「普通モード」なら120秒です。
            </div>
    </details>
    <details>
        <summary>Q1-3. </summary>
            <div class="answer">
                //
            </div>
    </details>

    <h2>2. ゲーム制作について</h2>
    <details>
        <summary>Q2-1. どんなセンサーを使っているの？</summary>
            <div class="answer">
                schoomyの距離センサーを使っています。これは、超音波を使って距離を測定するセンサーです。センサーから超音波を出し、物体に当たって跳ね返ってくるまでの時間を測定することで距離を計算しています。
            </div>
    </details>
    <details>
        <summary>Q2-2. schoomyのプログラムってどうやるの？</summary>
            <div class="answer">
                schoomyは、Scratchベースのビジュアルプログラミング環境を使ってプログラムを作成します。ブロックを組み合わせてプログラムを作成し、センサーの値を取得したり、Unityにデータを送信したりします。
                <br>
                ※以下の画像は、実際にschoomyでプログラムを作成している様子です。
                <br>
                <img src="./assets/picture/schoomy_image.png" alt="schoomyでの作成の様子" title="schoomyでの作成の様子" width="300" height="200">
            </div>
    </details>
    <details>
        <summary>Q2-3. どうやってキャラクターを動かしているの？</summary>
            <div class="answer">
                schoomyの距離センサーからリアルタイムで値を所得してUnityに送っています。Unityでは取得した値を元に、プレイヤーがどの様な操作をしているかを判定して、それに合わせてキャラクターの動きを制御しています。
            </div> 
    </details>
    <details>
        <summary>Q2-4. キャラクターを前進させるのはどうやっているの？</summary>
            <div class="answer">
                腹筋ローラーを前に伸ばすと距離センサーの値が小さくなり、反対に、腹筋ローラーを手前に引くと距離センサーの値が大きくなります。基本的には、距離センサーからの値が小さくなれば腹筋ローラーを前に伸ばしている、距離センサーからの値が大きくなれば腹筋ローラーを手前に引いていると判定されます。しかし、距離センサーの値にはノイズが入りやすいため、距離センサーからの値をそのまま使うとキャラクターが意図しない挙動をすることがあります。そこで、距離センサーからの値を平均的に値を扱うことでノイズの影響を軽減しています。
                <br>
                <details>
                    <summary>具体的に</summary>
                        <div class="answer">
                            過去32回分の距離センサーからの値を、キャラクターを動かすためのスクリプト内で１次元配列として保持しておき、距離センサーから値が送られてくる度に、「横軸がindex番号を逆順から、縦軸が距離センサーからの値」という座標平面を考えここに32個全ての値をプロットしていきます。そして、最新の値（index番号が一番大きい値）が原点に来るように、全ての点を並行移動させます。次に、これらの点を原点を通る１次式で近似し、その直線の傾きを求めます。その値が正であれば腹筋ローラーを前に伸ばしている、負であれば腹筋ローラーを手前に引いていると判断できます。ただし、傾きの絶対値が一定の値未満の場合は、腹筋ローラーを動かしていないと判断します。
                            <details>
                                <summary>なんで32回分なの？</summary>
                                    <div class="answer">
                                        一言で言うと、試行錯誤の結果です。初めは20回で作っていましたが、動作確認を繰り返して、やっぱりもうちょっとノイズを減らしたいという結論になりました。確かに、保持する数を増やせば増やすほどノイズは減っていきます。しかし、保持する数を増やす程、値をプロットして作った直線の傾きが、最新の値に対して鈍感になってしまいます。そこで、ノイズを減らしつつ、最新の値に対してもある程度敏感に反応するようにいろんな数で試したところ、32回分という数に落ち着きました。
                                    </div>
                            </details>
                        </div>
                </details>
            </div>
    </details>
    <details>
        <summary>Q2-5. ジャンプはどうしているの？</summary>
            <div class="answer">
                ジャンプでどのくらい飛ぶかは、「チャージゲージがどれだけたまっているか」と「ジャンプする時に腹筋ローラーをどれだけ前に伸ばしたか」の２つの要素で決まります。ジャンプした時に、チャージゲージが溜まっている程、鉛直上向きの初速度が大きくなります。また、ジャンプした時に腹筋ローラーを前に伸ばしている程、前方への初速度が大きくなります。これらの鉛直方向と水平方向の初速度を元に、斜方投射の式を使ってジャンプの軌道を計算しています。`Time.deltaTime`を使えば、１フレームの時間を取得できるため、ジャンプ開始時点の時刻をt = 0として、Update関数の中でTransform.positionにジャンプの軌道の計算結果を代入して、ジャンプの動きを実現しています。
                <br>
                <details>
                    <summary>どうしてUnityの物理演算を使わなかったの？（裏話的な感じになります）</summary>
                        <div class="answer">
                            一言で言えば、作り直すのが大変だったからです。もともと、芋虫が前進する動きもジャンプの動きも、どちらもTransform.positionの値を毎フレーム書き換えることで実現していました。しかし、ある時実際に動作確認をしていたら、センサーの値を受け取ってから約３秒という非常に大きなラグが発生していることに気がつきました。その原因を調べたところ、「Transform.positioinを毎フレーム上書きするのは、かなり負荷がかかること」だと分かり、試しに前進の動きをRigidbodyを使った物理演算に変えてみたところ、ラグが解消されました。そこで、ジャンプの動きの方もAddForce関数を使って書き換えようと思いましたが、これまで、物体に重力がかからない設定でゲームを作っていて、ジャンプの水平方向の動きはAddForce関数を使っても問題ありませんが、鉛直方向の動きは、重力がかからないため、AddForce関数を使うとずっと上に飛んでいってしまいます。しかし、重力がかかる設定に変えると、今まで通りうまく動かなくなるかもしれないとリーダーに言われ、ジャンプの動きはTransform.positionによる制御でもラグが目立たなかったため、ジャンプの動きはそのままにしておくことにしました。
                        </div>
                </details>
                <details>
                    <summary>ジャンプの裏話（上の続き的な）</summary>
                        <div class="answer">
                            ジャンプの動きは最後までTransform.positionによる制御のままでしたが、その中で何度も仕様変更がありました。
                        </div>
                </details>
            </div>
    </details>
</body>
</html>