<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q&A</title>
    <style>
        details {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: .75rem 1rem;
            margin: .5rem 0;
            background: #fafafa;
        }
        summary {
            cursor: pointer;
            font-weight: 600;
            list-style: none; /* Firefox 用 */
        }

        /* 既定の三角マーカーを消して独自のアイコンを付ける */
        summary::-webkit-details-marker { display: none; }
        summary::before {
            content: "▸";
            display: inline-block;
            width: 1em;
            transition: transform .2s;
            margin-right: .25rem;
        }

        details[open] > summary::before {
            transform: rotate(90deg);
        }
        .answer { margin-top: .5rem; line-height: 1.8; }
    </style>
    
    <!-- MathJax を追加 -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1>Game Q&A</h1>
    <p>
        <!-- このページは日本語版のQ&Aページを英語に翻訳したものです。翻訳には翻訳ツールを使用しているため、ご了承ください。 -->
        This page is a translation of the Japanese Q&A into English. Please note that translation tools were used for this translation.
    </p>
    <h2>1. About the game's content</h2>
    <details>
        <summary><span style="color: #ed2121;">First up, this!</span></summary>
            <div class="answer">
                You can watch the tutorial video via the link in the QR code below. Please take a look!
                <br>
                <img src="./assets/picture/tutorial_qr.png" alt="チュートリアルの動画のリンクのqrコード" title="チュートリアルの動画のリンクのqrコード" width="200" height="200">
                <br>
                You can also view it via the link below.
                <br>
                <a href="https://drive.google.com/file/d/1SU7uafm-JjhuoYs76C8XnxSBoK2JRYGv/view?usp=sharing">Click here</a>
            </div>
    </details>
    <details>
        <summary>Q1-1. How does the difficulty selection work?</summary>
            <div class="answer">
                There are two difficulty levels: “Easy” and “Normal". For “Easy Mode", roll the ab roller out to the yellow leaf line and then back to the green line. For “Normal Mode", roll it out to the far red leaf line and then back to the green line.
                <br>
                ※In-game text displays as “かんたん” and “ふつう” in hiragana.
            </div>
    </details>
    <details>
        <summary>Q1-2. How long is one play?</summary>
            <div class="answer">
                Each difficulty level has a time limit set: 80 seconds for Easy Mode and 120 seconds for Normal Mode.
            </div>
    </details>

    <h2>2. About Game Development</h2>
    <details>
        <summary>Q2-1. What kind of sensor are you using?</summary>
            <div class="answer">
                We are using a Schoomy distance sensor. This is a sensor that measures distance using ultrasonic waves. It calculates distance by emitting ultrasonic waves from the sensor and measuring the time it takes for the waves to bounce back after hitting an object.
            </div>
    </details>
    <details>
        <summary>Q2-2. How do you run the schoomy program?</summary>
            <div class="answer">
                Schoomy creates programs using a Scratch-based visual programming environment. You build programs by combining blocks, retrieve sensor values, and send data to Unity.
                <br>
                ※The following images show the actual process of creating a program in Schoomy.
                <br>
                <img src="./assets/picture/schoomy_image.png" alt="schoomyでの作成の様子" title="schoomyでの作成の様子" width="300" height="200">
            </div>
    </details>
    <details>
        <summary>Q2-3. How do you animate the characters?</summary>
            <div class="answer">
                We are obtaining values in real time from the Schoomy distance sensor and sending them to Unity. In Unity, based on the acquired values, we determine what kind of operation the player is performing and control the character's movements accordingly.
            </div> 
    </details>
    <details>
        <summary>Q2-4. How do you make the character move forward?</summary>
            <div class="answer">
                When you extend the ab roller forward, the distance sensor value decreases; conversely, when you pull the ab roller toward you, the distance sensor value increases. Fundamentally, a smaller value from the distance sensor indicates the ab roller is being pushed forward, while a larger value indicates it is being pulled back. However, the distance sensor value is prone to noise. Using the raw sensor value directly can cause the character to behave unexpectedly. Therefore, we mitigate the noise's impact by averaging the distance sensor values.
                <br>
                <details>
                    <summary>Specifically</summary>
                        <div class="answer">
                            The script storing the character's movement holds the last 32 distance sensor readings as a one-dimensional array. Each time a new value arrives from the sensor, all existing values in the array are shifted one position forward, with the new value added to the end. We then consider a coordinate plane where the horizontal axis represents the index number in reverse order (newest first) and the vertical axis represents the distance sensor value. All 32 values are plotted on this plane. Next, we parallel-shift all points so that the latest value (the one with the largest index number) is at the origin. We then approximate these points with a linear equation passing through the origin and calculate the slope of this line. If the slope value is positive, we determine that the ab roller is being pushed forward; if negative, it is being pulled back. However, if the absolute value of the slope is below a certain threshold, we determine that the ab roller is not being moved.
                            <details>
                                <summary>Why 32 times?</summary>
                                    <div class="answer">
                                        In a nutshell, it’s the result of trial and error. Initially, we were using 20 iterations, but after repeated testing, we concluded we wanted to reduce the noise a bit more. Indeed, increasing the number of iterations does reduce noise. However, the more iterations used, the less sensitive the slope of the line created by plotting the values becomes to the latest data point. So, we experimented with various numbers to find a balance between reducing noise and maintaining some responsiveness to the latest values, settling on 32 iterations.
                                    </div>
                            </details>
                            <details>
                                <summary>How are you performing the first-order approximation?</summary>
                                    <div class="answer">
                                        We are seeking the line（\(y = ax\)）passing through the origin that minimizes the mean squared error. You can find the slope \(a\) using the following equation. $$a = \sqrt{\frac{\sum x_{i} y_{i}}{\sum x_{i}^2}}$$
                                    </div>
                            </details>
                        </div>
                </details>
            </div>
    </details>
    <details>
        <summary>Q2-5. How's Jump doing?</summary>
            <div class="answer">
                How far you jump is determined by two factors: “how much the charge gauge is filled” and “how far forward you extend the ab roller when jumping”. The more the charge gauge is filled when you jump, the greater your initial vertical upward velocity becomes. Additionally, the further forward you extend the ab roller when jumping, the greater your forward initial velocity becomes. Using these initial velocities in the vertical and horizontal directions, the jump trajectory is calculated using the equation for oblique projection. By using `Time.deltaTime` to obtain the time per frame, the jump start time is set as t = 0. Within the Update function, the calculated jump trajectory result is assigned to Transform.position to implement the jump movement.
                <br>
                <details>
                    <summary>Why didn't you use Unity's physics engine?（It'll be more like behind-the-scenes stories.）</summary>
                        <div class="answer">
                            In short, it was because rebuilding it was a huge hassle. Originally, both the caterpillar's forward movement and its jumping motion were achieved by overwriting the Transform.position value every frame. However, while testing the actual movement one day, I noticed a significant lag of about three seconds after receiving the sensor values. Investigating the cause revealed that “overwriting Transform.position every frame places a considerable load on the system.” As a test, I changed the forward movement to use Rigidbody physics calculations. This drastically reduced the lag, making it negligible. I then considered rewriting the jump movement using the AddForce function. However, the game had been developed with gravity disabled for objects. While using AddForce for horizontal jump movement worked fine, applying it to vertical movement caused the character to fly upward indefinitely due to the absence of gravity. However, the leader pointed out that changing the settings to include gravity might cause the movement to stop working properly as before. Since the jump movement controlled by Transform.position didn't show noticeable lag, I decided to leave the jump movement as it was.
                        </div>
                </details>
                <details>
                    <summary>ジャンプの裏話（上の続き的な）</summary>
                        <div class="answer">
                            ジャンプの動きは最後までTransform.positionによる制御のままでしたが、その中で何度も仕様変更がありました。プレイヤーが操作できるのは、チャージゲージとジャンプ時の伸ばした量の２つというのは最初から変わりませんが、もともとは鉛直方向の力と水平方向の力は分かれていませんでした。ジャンプする角度を45°で固定して、２つの量にそれぞれ調整用の値をかけた値を足し合わせて、それを初速度として扱っていました。その状態でオープンキャンパスで来校者の方に実際にプレイしてもらったところ、「チャージゲージさえ溜めてしまえばジャンプする時に腹筋ローラーをあまり伸ばさなくても遠くまでジャンプできてしまい、腹筋ローラーを伸ばす必要性が少ない」という意見があがりました。そこで、チャージゲージとジャンプ時に腹筋ローラーを伸ばした量を別々に扱うようにすることにしました。そして、鉛直方向の運動にチャージゲージを紐付け、水平方向の運動にジャンプ時に腹筋ローラーを伸ばした量を紐付けることにしました。これにより、チャージゲージを溜めるだけで腹筋ローラーをあまり伸ばさないと、上にだけ高く飛んでほぼ垂直に落ちるようになり、大きくジャンプするにはチャージゲージを十分に溜めた上で、ジャンプする時に腹筋ローラーをしっかり前まで伸ばす必要が出てきました。これでジャンプのゲーム性の問題は解消されましたが、動作確認をしていたところ、ジャンプ時に伸ばした量の値をそのまま使っていると、ジャンプする時のブレ（腹筋ローラーを遠くまで伸ばしたのに、ほぼ真上に飛んでしまう）が大きく安定してジャンプがうまく出来ないことがわかりました。そこで、ジャンプを「弱」、「中」、「強」、「弱以下」の４段階に分けてみたところ、ジャンプのブレが小さくなり、安定してジャンプできるようになりました。ただ、これでも上手く判定してくれないことがたまにありますが、前の状態に比べれば大きく改善されていたため、これで良しとしました。
                        </div>
                </details>
            </div>
    </details>
</body>
</html>