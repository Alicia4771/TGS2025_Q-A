<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q&A</title>
    <style>
        details {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: .75rem 1rem;
            margin: .5rem 0;
            background: #fafafa;
        }
        summary {
            cursor: pointer;
            font-weight: 600;
            list-style: none; /* Firefox 用 */
        }

        /* 既定の三角マーカーを消して独自のアイコンを付ける */
        summary::-webkit-details-marker { display: none; }
        summary::before {
            content: "▸";
            display: inline-block;
            width: 1em;
            transition: transform .2s;
            margin-right: .25rem;
        }

        details[open] > summary::before {
            transform: rotate(90deg);
        }
        .answer { margin-top: .5rem; line-height: 1.8; }
    </style>
    
    <!-- MathJax を追加 -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1>Game Q&A</h1>
    <p>
        <!-- このページは日本語版のQ&Aページを英語に翻訳したものです。翻訳には翻訳ツールを使用しているため、ご了承ください。 -->
        This page is a translation of the Japanese Q&A into English. Please note that translation tools were used for this translation.
    </p>
    <h2>1. About the game's content</h2>
    <details>
        <summary><span style="color: #ed2121;">First up, this!</span></summary>
            <div class="answer">
                You can watch the tutorial video via the link in the QR code below. Please take a look!
                <br>
                <img src="./assets/picture/tutorial_qr.png" alt="チュートリアルの動画のリンクのqrコード" title="チュートリアルの動画のリンクのqrコード" width="200" height="200">
                <br>
                You can also view it via the link below.
                <br>
                <a href="https://drive.google.com/file/d/1SU7uafm-JjhuoYs76C8XnxSBoK2JRYGv/view?usp=sharing">Click here</a>
            </div>
    </details>
    <details>
        <summary>Q1-1. How does the difficulty selection work?</summary>
            <div class="answer">
                There are two difficulty levels: “Easy” and “Normal". For “Easy Mode", roll the ab roller out to the yellow leaf line and then back to the green line. For “Normal Mode", roll it out to the far red leaf line and then back to the green line.
                <br>
                ※In-game text displays as “かんたん” and “ふつう” in hiragana.
            </div>
    </details>
    <details>
        <summary>Q1-2. How long is one play?</summary>
            <div class="answer">
                Each difficulty level has a time limit set: 80 seconds for Easy Mode and 120 seconds for Normal Mode.
            </div>
    </details>

    <h2>2. About Game Development</h2>
    <details>
        <summary>Q2-1. What kind of sensor are you using?</summary>
            <div class="answer">
                We are using a Schoomy distance sensor. This is a sensor that measures distance using ultrasonic waves. It calculates distance by emitting ultrasonic waves from the sensor and measuring the time it takes for the waves to bounce back after hitting an object.
            </div>
    </details>
    <details>
        <summary>Q2-2. How do you run the schoomy program?</summary>
            <div class="answer">
                Schoomy creates programs using a Scratch-based visual programming environment. You build programs by combining blocks, retrieve sensor values, and send data to Unity.
                <br>
                ※The following images show the actual process of creating a program in Schoomy.
                <br>
                <img src="./assets/picture/schoomy_image.png" alt="schoomyでの作成の様子" title="schoomyでの作成の様子" width="300" height="200">
            </div>
    </details>
    <details>
        <summary>Q2-3. How do you animate the characters?</summary>
            <div class="answer">
                We are obtaining values in real time from the Schoomy distance sensor and sending them to Unity. In Unity, based on the acquired values, we determine what kind of operation the player is performing and control the character's movements accordingly.
            </div> 
    </details>
    <details>
        <summary>Q2-4. How do you make the character move forward?</summary>
            <div class="answer">
                When you extend the ab roller forward, the distance sensor value decreases; conversely, when you pull the ab roller toward you, the distance sensor value increases. Fundamentally, a smaller value from the distance sensor indicates the ab roller is being pushed forward, while a larger value indicates it is being pulled back. However, the distance sensor value is prone to noise. Using the raw sensor value directly can cause the character to behave unexpectedly. Therefore, we mitigate the noise's impact by averaging the distance sensor values.
                <br>
                <details>
                    <summary>Specifically</summary>
                        <div class="answer">
                            The script storing the character's movement holds the last 32 distance sensor readings as a one-dimensional array. Each time a new value arrives from the sensor, all existing values in the array are shifted one position forward, with the new value added to the end. We then consider a coordinate plane where the horizontal axis represents the index number in reverse order (newest first) and the vertical axis represents the distance sensor value. All 32 values are plotted on this plane. Next, we parallel-shift all points so that the latest value (the one with the largest index number) is at the origin. We then approximate these points with a linear equation passing through the origin and calculate the slope of this line. If the slope value is positive, we determine that the ab roller is being pushed forward; if negative, it is being pulled back. However, if the absolute value of the slope is below a certain threshold, we determine that the ab roller is not being moved.
                            <details>
                                <summary>Why 32 times?</summary>
                                    <div class="answer">
                                        In a nutshell, it’s the result of trial and error. Initially, we were using 20 iterations, but after repeated testing, we concluded we wanted to reduce the noise a bit more. Indeed, increasing the number of iterations does reduce noise. However, the more iterations used, the less sensitive the slope of the line created by plotting the values becomes to the latest data point. So, we experimented with various numbers to find a balance between reducing noise and maintaining some responsiveness to the latest values, settling on 32 iterations.
                                    </div>
                            </details>
                            <details>
                                <summary>How are you performing the first-order approximation?</summary>
                                    <div class="answer">
                                        We are seeking the line（\(y = ax\)）passing through the origin that minimizes the mean squared error. You can find the slope \(a\) using the following equation. $$a = \sqrt{\frac{\sum x_{i} y_{i}}{\sum x_{i}^2}}$$
                                    </div>
                            </details>
                        </div>
                </details>
            </div>
    </details>
    <details>
        <summary>Q2-5. ジャンプはどうしているの？</summary>
            <div class="answer">
                ジャンプでどのくらい飛ぶかは、「チャージゲージがどれだけたまっているか」と「ジャンプする時に腹筋ローラーをどれだけ前に伸ばしたか」の２つの要素で決まります。ジャンプした時にチャージゲージが溜まっている程、鉛直上向きの初速度が大きくなります。また、ジャンプした時に腹筋ローラーを前に伸ばしている程、前方への初速度が大きくなります。これらの鉛直方向と水平方向の初速度を元に、斜方投射の式を使ってジャンプの軌道を計算しています。`Time.deltaTime`を使えば、１フレームの時間を取得できるため、ジャンプ開始時点の時刻をt = 0として、Update関数の中でTransform.positionにジャンプの軌道の計算結果を代入して、ジャンプの動きを実現しています。
                <br>
                <details>
                    <summary>どうしてUnityの物理演算を使わなかったの？（裏話的な感じになります）</summary>
                        <div class="answer">
                            一言で言えば、作り直すのが大変だったからです。もともと、芋虫が前進する動きもジャンプの動きも、どちらもTransform.positionの値を毎フレーム書き換えることで実現していました。しかし、ある時実際に動作確認をしていたら、センサーの値を受け取ってから約３秒という非常に大きなラグが発生していることに気がつきました。その原因を調べたところ、「Transform.positioinを毎フレーム上書きするのは、かなり負荷がかかること」だと分かり、試しに前進の動きをRigidbodyを使った物理演算に変えてみたところ、ラグが大幅に解消され、気にならない程になりました。そこで、ジャンプの動きの方もAddForce関数を使って書き換えようと思いましたが、これまで、物体に重力がかからない設定でゲームを作っていて、ジャンプの水平方向の動きはAddForce関数を使っても問題ありませんが、鉛直方向の動きは、重力がかからないため、AddForce関数を使うとずっと上に飛んでいってしまいます。しかし、重力がかかる設定に変えると、今まで通りうまく動かなくなるかもしれないとリーダーに言われ、ジャンプの動きはTransform.positionによる制御でもラグが目立たなかったため、ジャンプの動きはそのままにしておくことにしました。
                        </div>
                </details>
                <details>
                    <summary>ジャンプの裏話（上の続き的な）</summary>
                        <div class="answer">
                            ジャンプの動きは最後までTransform.positionによる制御のままでしたが、その中で何度も仕様変更がありました。プレイヤーが操作できるのは、チャージゲージとジャンプ時の伸ばした量の２つというのは最初から変わりませんが、もともとは鉛直方向の力と水平方向の力は分かれていませんでした。ジャンプする角度を45°で固定して、２つの量にそれぞれ調整用の値をかけた値を足し合わせて、それを初速度として扱っていました。その状態でオープンキャンパスで来校者の方に実際にプレイしてもらったところ、「チャージゲージさえ溜めてしまえばジャンプする時に腹筋ローラーをあまり伸ばさなくても遠くまでジャンプできてしまい、腹筋ローラーを伸ばす必要性が少ない」という意見があがりました。そこで、チャージゲージとジャンプ時に腹筋ローラーを伸ばした量を別々に扱うようにすることにしました。そして、鉛直方向の運動にチャージゲージを紐付け、水平方向の運動にジャンプ時に腹筋ローラーを伸ばした量を紐付けることにしました。これにより、チャージゲージを溜めるだけで腹筋ローラーをあまり伸ばさないと、上にだけ高く飛んでほぼ垂直に落ちるようになり、大きくジャンプするにはチャージゲージを十分に溜めた上で、ジャンプする時に腹筋ローラーをしっかり前まで伸ばす必要が出てきました。これでジャンプのゲーム性の問題は解消されましたが、動作確認をしていたところ、ジャンプ時に伸ばした量の値をそのまま使っていると、ジャンプする時のブレ（腹筋ローラーを遠くまで伸ばしたのに、ほぼ真上に飛んでしまう）が大きく安定してジャンプがうまく出来ないことがわかりました。そこで、ジャンプを「弱」、「中」、「強」、「弱以下」の４段階に分けてみたところ、ジャンプのブレが小さくなり、安定してジャンプできるようになりました。ただ、これでも上手く判定してくれないことがたまにありますが、前の状態に比べれば大きく改善されていたため、これで良しとしました。
                        </div>
                </details>
            </div>
    </details>
</body>
</html>